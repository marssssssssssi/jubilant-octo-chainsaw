# Реализации структур данных на Python

# 1. Бинарная куча (Binary Heap) - min-heap
class BinaryHeap:
    def __init__(self):
        self.heap = []

    def insert(self, key):
        self.heap.append(key)
        self._heapify_up(len(self.heap) - 1)

    def delete_min(self):
        if self.is_empty():
            return None
        min_val = self.heap[0]
        last = self.heap.pop()
        if not self.is_empty():
            self.heap[0] = last
            self._heapify_down(0)
        return min_val

    def get_min(self):
        if self.is_empty():
            return None
        return self.heap[0]

    def is_empty(self):
        return len(self.heap) == 0

    def _heapify_up(self, i):
        while i > 0:
            parent = (i - 1) // 2
            if self.heap[i] < self.heap[parent]:
                self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]
                i = parent
            else:
                break

    def _heapify_down(self, i):
        size = len(self.heap)
        while True:
            left = 2 * i + 1
            right = 2 * i + 2
            smallest = i
            if left < size and self.heap[left] < self.heap[smallest]:
                smallest = left
            if right < size and self.heap[right] < self.heap[smallest]:
                smallest = right
            if smallest != i:
                self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
                i = smallest
            else:
                break

# Пример использования BinaryHeap
print("Binary Heap Example:")
bh = BinaryHeap()
bh.insert(3)
bh.insert(1)
bh.insert(4)
print(bh.get_min())  # 1
print(bh.delete_min())  # 1
print("")

# 2. Биномиальная куча (Binomial Heap) - упрощенная версия
class BinomialNode:
    def __init__(self, key):
        self.key = key
        self.degree = 0
        self.parent = None
        self.child = None
        self.sibling = None

class BinomialHeap:
    def __init__(self):
        self.head = None

    def insert(self, key):
        new_heap = BinomialHeap()
        new_heap.head = BinomialNode(key)
        self.head = self._union(self.head, new_heap.head)

    def extract_min(self):
        if not self.head:
            return None
        min_node = self._find_min()
        self._remove_min(min_node)
        return min_node.key

    def _find_min(self):
        if not self.head:
            return None
        min_node = self.head
        current = self.head.sibling
        while current:
            if current.key < min_node.key:
                min_node = current
            current = current.sibling
        return min_node

    def _remove_min(self, min_node):
        # Упрощенная версия: удаление корня и слияние детей
        prev = None
        current = self.head
        while current != min_node:
            prev = current
            current = current.sibling
        if prev:
            prev.sibling = min_node.sibling
        else:
            self.head = min_node.sibling
        child_heap = BinomialHeap()
        child = min_node.child
        while child:
            next_child = child.sibling
            child.sibling = child_heap.head
            child.parent = None
            child_heap.head = child
            child = next_child
        self.head = self._union(self.head, child_heap.head)

    def _union(self, h1, h2):
        if not h1:
            return h2
        if not h2:
            return h1
        # Сортировка по степени
        if h1.degree < h2.degree:
            h1.sibling = self._union(h1.sibling, h2)
            return h1
        else:
            h2.sibling = self._union(h1, h2.sibling)
            return h2
        # Упрощено; полная версия включает merge и carry

# Пример использования BinomialHeap
print("Binomial Heap Example:")
bh_binom = BinomialHeap()
bh_binom.insert(4)
bh_binom.insert(2)
bh_binom.insert(6)
print(bh_binom.extract_min())  # 2
print("")

# 3. Куча Фибоначчи (Fibonacci Heap) - упрощенная версия
class FibonacciNode:
    def __init__(self, key):
        self.key = key
        self.degree = 0
        self.parent = None
        self.child = None
        self.sibling = None
        self.marked = False

class FibonacciHeap:
    def __init__(self):
        self.min_node = None
        self.num_nodes = 0

    def insert(self, key):
        node = FibonacciNode(key)
        node.sibling = self.min_node
        if self.min_node:
            self.min_node.sibling = node
        if not self.min_node or key < self.min_node.key:
            self.min_node = node
        self.num_nodes += 1

    def extract_min(self):
        if not self.min_node:
            return None
        z = self.min_node
        if z.child:
            child = z.child
            while child:
                child.parent = None
                child.sibling = self.min_node.sibling
                self.min_node.sibling = child
                child = child.sibling
        # Удаление z
        self.min_node = z.sibling
        # Упрощено: без consolidate
        # Найти новый min
        if self.min_node:
            current = self.min_node.sibling
            min_val = self.min_node
            while current:
                if current.key < min_val.key:
                    min_val = current
                current = current.sibling
            self.min_node = min_val
        self.num_nodes -= 1
        return z.key

# Пример использования FibonacciHeap
print("Fibonacci Heap Example:")
fh = FibonacciHeap()
fh.insert(5)
fh.insert(3)
fh.insert(7)
print(fh.extract_min())  # 3
print("")

# 4. Хеш-таблица (Hash Table) с цепочками
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def set(self, key, value):
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:
                pair[1] = value
                return
        self.table[index].append([key, value])

    def get(self, key):
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:
                return pair[1]
        raise KeyError(f'Key {key} not found')

    def remove(self, key):
        index = self._hash(key)
        for i, pair in enumerate(self.table[index]):
            if pair[0] == key:
                del self.table[index][i]
                return
        raise KeyError(f'Key {key} not found')

# Пример использования HashTable
print("Hash Table Example:")
ht = HashTable()
ht.set('Alice', 'January')
ht.set('Bob', 'May')
print(ht.get('Alice'))  # 'January'
ht.remove('Bob')
# print(ht.get('Bob'))  # KeyError
